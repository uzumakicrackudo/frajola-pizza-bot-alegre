import { useState, useCallback } from 'react';
import { ChatMessage, ChatbotState, MenuItem, OrderItem, CustomerInfo } from '@/types/chatbot';
import { useOpenAI } from './useOpenAI';
import { ChatService } from '@/services/chatService';

export const useChatbot = (menu: MenuItem[], estimatedTime: number) => {
  const [state, setState] = useState<ChatbotState>({
    stage: 'greeting',
    currentOrder: {
      items: [],
      customerInfo: { name: '', street: '', number: '', neighborhood: '' },
      estimatedTime,
      total: 0
    },
    messages: [
      {
        id: '1',
        text: 'üçï Oi! Eu sou a Frajola, sua assistente virtual da pizzaria! üòä Estou aqui para te ajudar a fazer o melhor pedido! Como posso te ajudar hoje?',
        sender: 'bot',
        timestamp: new Date()
      }
    ],
    awaitingHuman: false
  });

  const { callOpenAI, isLoading } = useOpenAI();
  const chatService = new ChatService(menu);

  // Contexto da conversa
  const [conversationContext, setConversationContext] = useState<{
    lastQueriedItem: MenuItem | null;
    lastAction: 'price' | 'ingredients' | 'menu' | null;
    addressField: 'name' | 'street' | 'number' | 'neighborhood' | null;
  }>({
    lastQueriedItem: null,
    lastAction: null,
    addressField: null
  });

  const addMessage = useCallback((text: string, sender: 'user' | 'bot') => {
    const newMessage: ChatMessage = {
      id: Date.now().toString(),
      text,
      sender,
      timestamp: new Date()
    };

    setState(prev => ({
      ...prev,
      messages: [...prev.messages, newMessage]
    }));
  }, []);

  // Fun√ß√£o melhorada para normalizar texto
  const normalizeText = useCallback((text: string): string => {
    return text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove acentos
      .replace(/[^\w\s]/g, ' ') // Substitui pontua√ß√£o por espa√ßo
      .replace(/\s+/g, ' ') // Normaliza espa√ßos
      .trim();
  }, []);

  // Fun√ß√£o MUITO mais restritiva para encontrar itens no menu
  const findMenuItem = useCallback((query: string): MenuItem | null => {
    const normalizedQuery = normalizeText(query);
    console.log('üîç Buscando por:', normalizedQuery);
    
    // Se a query for muito pequena, n√£o buscar
    if (normalizedQuery.length < 3) {
      console.log('‚ùå Query muito pequena');
      return null;
    }
    
    // Palavras que N√ÉO s√£o itens do menu (expandida)
    const stopWords = [
      'ola', 'ol√°', 'oi', 'e ai', 'eai', 'bom dia', 'boa tarde', 'boa noite',
      'obrigado', 'obrigada', 'valeu', 'tchau', 'ate logo', 'at√© logo',
      'sim', 'nao', 'n√£o', 'ok', 'certo', 'beleza', 'legal', 'show',
      'quanto', 'como', 'onde', 'quando', 'porque', 'por que', 'que',
      'cardapio', 'menu', 'pedido', 'pedir', 'quero', 'gostaria', 
      'pode', 'consegue', 'ajuda', 'ajudar', 'oque', 'o que',
      'vai', 'tem', 'ingrediente', 'ingredientes', 'feita', 'pizza', 'de'
    ];
    
    // Se for apenas uma palavra comum, n√£o buscar
    const queryWords = normalizedQuery.split(' ').filter(word => word.length > 2);
    if (queryWords.every(word => stopWords.includes(word))) {
      console.log('‚ùå Apenas palavras comuns detectadas');
      return null;
    }
    
    // Mapeamento EXATO de nomes (mais restritivo)
    const exactMatches: { [key: string]: string } = {
      'calabresa': 'Pizza Calabresa',
      'margherita': 'Pizza Margherita',
      'marguerita': 'Pizza Margherita',
      'portuguesa': 'Pizza Portuguesa',
      'frango catupiry': 'Pizza Frango com Catupiry',
      'frango': 'Pizza Frango com Catupiry',
      'presunto queijo': 'Pizza Presunto e Queijo',
      'presunto': 'Pizza Presunto e Queijo',
      'fernando': 'Pizza Fernando',
      'mussarela': 'Pizza Mussarela',
      '4 queijos': 'Pizza 4 Queijos',
      'quatro queijos': 'Pizza 4 Queijos',
      '3 queijos': 'Pizza 3 Queijos',
      'tres queijos': 'Pizza 3 Queijos',
      '2 queijos': 'Pizza 2 Queijos',
      'dois queijos': 'Pizza 2 Queijos',
      'file mignon': 'Pizza Fil√© Mignon',
      'file': 'Pizza Fil√© Mignon',
      'mignon': 'Pizza Fil√© Mignon',
      '4 carnes': 'Pizza 4 Carnes',
      'quatro carnes': 'Pizza 4 Carnes',
      'lombo catupiry': 'Pizza Lombo com Catupiry',
      'lombo': 'Pizza Lombo com Catupiry',
      'frango especial': 'Pizza Frango Especial',
      'strogonoff': 'Pizza Strogonoff',
      'frango melt': 'Pizza Frango Melt',
      'melt': 'Pizza Frango Melt',
      'palmito catupiry': 'Pizza Palmito com Catupiry',
      'palmito': 'Pizza Palmito com Catupiry',
      'milho catupiry': 'Pizza Milho com Catupiry',
      'milho': 'Pizza Milho com Catupiry',
      'brocolis': 'Pizza Br√≥colis',
      'rucula': 'Pizza R√∫cula',
      'coca': 'Coca Cola 350ml',
      'coca cola': 'Coca Cola 350ml',
      'guarana': 'Guaran√° 350ml',
      'suco laranja': 'Suco de Laranja 300ml',
      'suco': 'Suco de Laranja 300ml'
    };

    // 1. Busca por correspond√™ncia exata primeiro
    for (const [key, itemName] of Object.entries(exactMatches)) {
      if (normalizedQuery.includes(key)) {
        const found = menu.find(item => 
          item.available && normalizeText(item.name) === normalizeText(itemName)
        );
        if (found) {
          console.log('‚úÖ Encontrado por mapeamento exato:', found.name);
          return found;
        }
      }
    }

    // 2. Busca por palavras-chave espec√≠ficas mais restritiva
    const specificKeywords = [
      { keywords: ['calabresa'], requiredWords: ['calabresa'] },
      { keywords: ['margherita', 'marguerita'], requiredWords: ['margherita'] },
      { keywords: ['portuguesa'], requiredWords: ['portuguesa'] },
      { keywords: ['frango'], requiredWords: ['frango'] },
      { keywords: ['presunto'], requiredWords: ['presunto'] },
      { keywords: ['fernando'], requiredWords: ['fernando'] },
      { keywords: ['mussarela'], requiredWords: ['mussarela'] },
      { keywords: ['file', 'mignon'], requiredWords: ['file', 'mignon'] },
      { keywords: ['lombo'], requiredWords: ['lombo'] },
      { keywords: ['strogonoff'], requiredWords: ['strogonoff'] },
      { keywords: ['palmito'], requiredWords: ['palmito'] },
      { keywords: ['milho'], requiredWords: ['milho'] },
      { keywords: ['brocolis'], requiredWords: ['brocolis'] },
      { keywords: ['rucula'], requiredWords: ['rucula'] }
    ];

    for (const keywordGroup of specificKeywords) {
      const hasAllRequired = keywordGroup.requiredWords.every(word => 
        normalizedQuery.includes(word)
      );
      
      if (hasAllRequired) {
        const hasKeyword = keywordGroup.keywords.some(keyword => 
          normalizedQuery.includes(keyword)
        );
        
        if (hasKeyword) {
          const found = menu.find(item => {
            if (!item.available) return false;
            const itemNormalized = normalizeText(item.name);
            return keywordGroup.requiredWords.every(word => itemNormalized.includes(word));
          });
          
          if (found) {
            console.log('‚úÖ Encontrado por palavra-chave espec√≠fica:', found.name);
            return found;
          }
        }
      }
    }

    console.log('‚ùå Nenhum item encontrado para:', normalizedQuery);
    return null;
  }, [menu, normalizeText]);

  const getItemIcon = useCallback((item: MenuItem): string => {
    switch (item.category) {
      case 'pizza':
        return 'üçï';
      case 'bebida':
        if (item.name.toLowerCase().includes('coca')) return 'ü•§';
        if (item.name.toLowerCase().includes('guaran√°')) return 'ü•§';
        if (item.name.toLowerCase().includes('suco')) return 'üßÉ';
        return 'ü•§';
      case 'entrada':
        return 'ü•ñ';
      case 'sobremesa':
        return 'üç∞';
      default:
        return 'üçΩÔ∏è';
    }
  }, []);

  const addItemToOrder = useCallback((item: MenuItem, size: 'grande' | 'broto' = 'grande') => {
    const price = size === 'broto' && item.priceSmall ? item.priceSmall : item.price;
    
    setState(prev => ({
      ...prev,
      currentOrder: {
        ...prev.currentOrder,
        items: [...prev.currentOrder.items, {
          menuItem: { ...item, price },
          quantity: 1,
          removedIngredients: []
        }],
        total: prev.currentOrder.total + price
      }
    }));
  }, []);

  const processMessage = useCallback(async (userMessage: string) => {
    addMessage(userMessage, 'user');

    const shouldUseAI = chatService.shouldUseOpenAI(userMessage);
    
    setState(currentState => {
      const lowerMessage = userMessage.toLowerCase();

      // Sempre processar solicita√ß√µes de humano primeiro
      if (lowerMessage.includes('humano') || lowerMessage.includes('atendente') || 
          lowerMessage.includes('pessoa') || lowerMessage.includes('ajuda especializada')) {
        
        setTimeout(() => {
          addMessage('ü§ù Claro! Vou te conectar com um de nossos atendentes humanos. Aguarde s√≥ um instantinho...', 'bot');
        }, 100);
        
        return { ...currentState, stage: 'human', awaitingHuman: true };
      }

      // L√≥gica espec√≠fica da pizzaria (sempre priorit√°ria)
      if (!shouldUseAI || currentState.stage === 'address' || currentState.stage === 'ordering') {
        
        if (currentState.stage === 'address') {
          if (!conversationContext.addressField) {
            setTimeout(() => {
              addMessage('üìç Perfeito! Agora me diga o nome da sua rua:', 'bot');
            }, 100);
            
            setConversationContext(prev => ({ ...prev, addressField: 'street' }));
            
            return {
              ...currentState,
              currentOrder: {
                ...currentState.currentOrder,
                customerInfo: { ...currentState.currentOrder.customerInfo, name: userMessage }
              }
            };
          } else if (conversationContext.addressField === 'street') {
            setTimeout(() => {
              addMessage('üè† Agora me diga o n√∫mero da sua casa:', 'bot');
            }, 100);
            
            setConversationContext(prev => ({ ...prev, addressField: 'number' }));
            
            return {
              ...currentState,
              currentOrder: {
                ...currentState.currentOrder,
                customerInfo: { ...currentState.currentOrder.customerInfo, street: userMessage }
              }
            };
          } else if (conversationContext.addressField === 'number') {
            setTimeout(() => {
              addMessage('üèòÔ∏è Por √∫ltimo, qual √© o seu bairro?', 'bot');
            }, 100);
            
            setConversationContext(prev => ({ ...prev, addressField: 'neighborhood' }));
            
            return {
              ...currentState,
              currentOrder: {
                ...currentState.currentOrder,
                customerInfo: { ...currentState.currentOrder.customerInfo, number: userMessage }
              }
            };
          } else if (conversationContext.addressField === 'neighborhood') {
            const updatedOrder = {
              ...currentState.currentOrder,
              customerInfo: { ...currentState.currentOrder.customerInfo, neighborhood: userMessage }
            };
            
            setTimeout(() => {
              const orderSummary = updatedOrder.items.map(item => 
                `${getItemIcon(item.menuItem)} ${item.menuItem.name} - R$ ${item.menuItem.price.toFixed(2)}`
              ).join('\n');
              
              addMessage(`üéâ Pedido confirmado! Aqui est√° o resumo:

üìã **RESUMO DO PEDIDO:**
${orderSummary}

üí∞ **Total:** R$ ${updatedOrder.total.toFixed(2)}

üè† **Endere√ßo de entrega:**
${updatedOrder.customerInfo.name}
${updatedOrder.customerInfo.street}, ${updatedOrder.customerInfo.number}
${updatedOrder.customerInfo.neighborhood}

‚è∞ **Tempo estimado:** ${estimatedTime} minutos

‚úÖ Seu pedido foi registrado! Nossa equipe j√° come√ßou a preparar. Voc√™ receber√° uma liga√ß√£o para confirmar os detalhes!

Obrigada por escolher a Pizzaria Frajola! üçï‚ù§Ô∏è`, 'bot');
            }, 100);
            
            setConversationContext(prev => ({ ...prev, addressField: null }));
            
            return {
              ...currentState,
              stage: 'confirmation',
              currentOrder: updatedOrder
            };
          }
        }

        // Comando finalizar pedido
        if (lowerMessage.includes('finalizar')) {
          if (currentState.currentOrder.items.length === 0) {
            setTimeout(() => {
              addMessage('ü§î Opa! Voc√™ ainda n√£o escolheu nada! Que tal dar uma olhada no nosso card√°pio? Digite "card√°pio" para ver nossas del√≠cias! üòä', 'bot');
            }, 100);
            return currentState;
          }
          
          setTimeout(() => {
            addMessage('üè† Perfeito! Agora vou precisar do seu endere√ßo para entrega. Primeiro, qual √© o seu nome?', 'bot');
          }, 100);
          
          setConversationContext(prev => ({ ...prev, addressField: null }));
          return { ...currentState, stage: 'address' };
        }

        // Comando continuar pedido
        if (lowerMessage.includes('continuar pedido') || lowerMessage.includes('continuar')) {
          setTimeout(() => {
            addMessage('üòã √ìtimo! O que mais voc√™ gostaria de adicionar? Posso te mostrar o card√°pio novamente se quiser!', 'bot');
          }, 100);
          return { ...currentState, stage: 'ordering' };
        }

        // Consultas sobre ingredientes - MELHORADA
        if (lowerMessage.includes('ingrediente') || lowerMessage.includes('tem o que') || 
            lowerMessage.includes('feita com') || lowerMessage.includes('oque vai') || 
            lowerMessage.includes('o que vai')) {
          const item = findMenuItem(userMessage);
          if (item) {
            let ingredientsText;
            if (item.ingredients.length > 0) {
              const ingredientsList = item.ingredients.join(', ');
              ingredientsText = `üçÖ A ${getItemIcon(item)} ${item.name} leva: ${ingredientsList}! 

Uma combina√ß√£o perfeita que vai te deixar com √°gua na boca! üòã 

Gostaria de adicionar ao pedido? √â s√≥ falar "quero"!`;
            } else {
              ingredientsText = `${getItemIcon(item)} A ${item.name} j√° vem prontinha para voc√™! ü•§

Que tal adicionar ao pedido? Fala "quero" que eu coloco! üòä`;
            }
            
            setTimeout(() => {
              addMessage(ingredientsText, 'bot');
            }, 100);
            
            setConversationContext({ lastQueriedItem: item, lastAction: 'ingredients', addressField: null });
          } else {
            setTimeout(() => {
              addMessage('ü§î Hmm, n√£o consegui identificar qual item voc√™ est√° perguntando! Pode me falar o nome da pizza de novo? Ou digite "card√°pio" para ver todas as op√ß√µes! üòä', 'bot');
            }, 100);
          }
          return currentState;
        }

        // Consultas sobre pre√ßo - MELHORADA
        if (lowerMessage.includes('pre√ßo') || lowerMessage.includes('quanto custa') || 
            lowerMessage.includes('valor') || lowerMessage.includes('quanto')) {
          const item = findMenuItem(userMessage);
          if (item) {
            let priceText = `üí∞ A ${getItemIcon(item)} ${item.name} sai por R$ ${item.price.toFixed(2)}`;
            if (item.priceSmall) {
              priceText += ` (tamanho grande) ou R$ ${item.priceSmall.toFixed(2)} (broto)`;
            }
            priceText += `! 

Um pre√ßo justo por uma pizza deliciosa! üòã Gostaria de adicionar ao pedido?`;
            
            setTimeout(() => {
              addMessage(priceText, 'bot');
            }, 100);
            
            setConversationContext({ lastQueriedItem: item, lastAction: 'price', addressField: null });
          } else {
            setTimeout(() => {
              addMessage('ü§î N√£o consegui identificar qual item voc√™ quer saber o pre√ßo! Pode repetir o nome? Ou digite "card√°pio" para ver tudo com os pre√ßos! üí∞', 'bot');
            }, 100);
          }
          return currentState;
        }

        // Busca direta por item - MUITO MELHORADA
        const directItem = findMenuItem(userMessage);
        if (directItem && !lowerMessage.includes('card√°pio') && !lowerMessage.includes('menu')) {
          let itemText = `${getItemIcon(directItem)} √ìtima escolha! A ${directItem.name} √© uma das nossas queridinhas! üòç`;
          
          if (directItem.ingredients.length > 0) {
            const ingredientsList = directItem.ingredients.join(', ');
            itemText += `\n\nüçÖ Vem com: ${ingredientsList}`;
          }
          
          itemText += `\nüí∞ Pre√ßo: R$ ${directItem.price.toFixed(2)}`;
          if (directItem.priceSmall) {
            itemText += ` (grande) ou R$ ${directItem.priceSmall.toFixed(2)} (broto)`;
          }
          
          itemText += '\n\nüòã Quer colocar no pedido? √â s√≥ falar "quero"!';
          
          setTimeout(() => {
            addMessage(itemText, 'bot');
          }, 100);
          
          setConversationContext({ lastQueriedItem: directItem, lastAction: null, addressField: null });
          return currentState;
        }

        // Verificar se quer adicionar o item do contexto
        if ((lowerMessage.includes('quero') || lowerMessage.includes('vou querer') || 
             lowerMessage.includes('adicionar') || lowerMessage.includes('pedir')) && 
             conversationContext.lastQueriedItem && !findMenuItem(userMessage)) {
          const item = conversationContext.lastQueriedItem;
          const newTotal = currentState.currentOrder.total + item.price;
          
          setTimeout(() => {
            addMessage(`üéâ Perfeito! Coloquei a ${getItemIcon(item)} ${item.name} no seu pedido! 

üí∞ **Total atual:** R$ ${newTotal.toFixed(2)}

Quer adicionar mais alguma coisa? Fala "continuar pedido" ou "finalizar" para prosseguir! üòä`, 'bot');
          }, 100);

          return {
            ...currentState,
            stage: 'ordering',
            currentOrder: {
              ...currentState.currentOrder,
              items: [...currentState.currentOrder.items, {
                menuItem: { ...item },
                quantity: 1,
                removedIngredients: []
              }],
              total: newTotal
            }
          };
        }

        if (lowerMessage.includes('card√°pio') || lowerMessage.includes('menu') || lowerMessage.includes('op√ß√µes')) {
          const pizzas = menu.filter(item => item.category === 'pizza' && item.available);
          const bebidas = menu.filter(item => item.category === 'bebida' && item.available);
          const bordas = menu.filter(item => item.category === 'entrada' && item.available);
          const sobremesas = menu.filter(item => item.category === 'sobremesa' && item.available);
          
          let menuText = 'üìã Aqui est√° nosso delicioso card√°pio da Pizzaria Frajola! üçï\n\nüçï PIZZAS CL√ÅSSICAS & ESPECIAIS:\n';
          pizzas.slice(0, 10).forEach(pizza => {
            menuText += `${getItemIcon(pizza)} ${pizza.name} - R$ ${pizza.price.toFixed(2)}\n`;
          });
          
          if (bordas.length > 0) {
            menuText += '\nü•ñ BORDAS RECHEADAS:\n';
            bordas.forEach(borda => {
              menuText += `${getItemIcon(borda)} ${borda.name} - R$ ${borda.price.toFixed(2)}\n`;
            });
          }
          
          if (bebidas.length > 0) {
            menuText += '\nü•§ BEBIDAS:\n';
            bebidas.forEach(bebida => {
              menuText += `${getItemIcon(bebida)} ${bebida.name} - R$ ${bebida.price.toFixed(2)}\n`;
            });
          }
          
          menuText += '\nüí° Dica: Pergunte "o que vai na pizza de calabresa?" ou "quanto custa a margherita?" üòä\nüì± Delivery: (17) - @pizzariamassamia';
          
          setTimeout(() => {
            addMessage(menuText, 'bot');
          }, 100);
          
          setConversationContext({ lastQueriedItem: null, lastAction: 'menu', addressField: null });
          return currentState;
        }

        // Fazer pedido
        if (lowerMessage.includes('pedido') || lowerMessage.includes('quero') || lowerMessage.includes('pedir')) {
          setTimeout(() => {
            addMessage('üéâ Que bom! Vamos fazer seu pedido! Me diga qual pizza voc√™ quer, posso personalizar removendo ingredientes se preferir! E n√£o esque√ßa das nossas bordas recheadas! üòã', 'bot');
          }, 100);
          
          return { ...currentState, stage: 'ordering' };
        }
      }

      // Usar ChatGPT para conversas casuais
      if (shouldUseAI) {
        const recentMessages = currentState.messages.slice(-5).map(msg => msg.text);
        const context = chatService.createContextForOpenAI(recentMessages);
        
        callOpenAI(userMessage, context).then(aiResponse => {
          if (aiResponse.includes('problemas t√©cnicos') || aiResponse.includes('quota')) {
            if (chatService.isCasualConversation(userMessage)) {
              addMessage('üòä Oi! Eu sou a Frajola da Pizzaria! Como posso te ajudar hoje? Posso mostrar nosso card√°pio, ajudar com pedidos ou tirar suas d√∫vidas sobre nossas deliciosas pizzas! üçï', 'bot');
            } else {
              addMessage('üòä Desculpe, n√£o entendi muito bem! Mas posso te ajudar com:\n\n‚Ä¢ Ver o card√°pio completo\n‚Ä¢ Consultar pre√ßos e ingredientes\n‚Ä¢ Fazer um pedido\n‚Ä¢ Falar com um atendente humano\n\nO que voc√™ gostaria de fazer? üçï', 'bot');
            }
          } else {
            addMessage(aiResponse, 'bot');
          }
        }).catch(() => {
          addMessage('üòä Oi! Sou a Frajola da Pizzaria! Como posso te ajudar hoje? Digite "card√°pio" para ver nossas deliciosas op√ß√µes! üçï', 'bot');
        });
        
        return currentState;
      }

      // Fallback melhorado
      setTimeout(() => {
        addMessage('üòä Ops! N√£o entendi direito! Mas posso te ajudar com:\n\n‚Ä¢ "card√°pio" - ver todas as pizzas\n‚Ä¢ "o que vai na pizza de calabresa?" - ingredientes\n‚Ä¢ "quanto custa a margherita?" - pre√ßos\n‚Ä¢ "quero fazer um pedido" - come√ßar pedido\n‚Ä¢ "humano" - falar com atendente\n\nO que voc√™ gostaria? üçï', 'bot');
      }, 100);
      
      return currentState;
    });
  }, [addMessage, findMenuItem, menu, estimatedTime, conversationContext, getItemIcon, callOpenAI, chatService]);

  return {
    state,
    setState,
    addMessage,
    processMessage,
    findMenuItem,
    conversationContext,
    isLoadingAI: isLoading
  };
};
